// This file is generated by kconfig_compiler from ipv6.kcfg.
// All changes you do to this file will be lost.

#include "ipv6persistence.h"

#include "ipv6.h"

using namespace Knm;

Ipv6Persistence::Ipv6Persistence(Ipv6Setting * setting, KSharedConfig::Ptr config, ConnectionPersistence::SecretStorageMode mode) : SettingPersistence(setting, config, mode)
{
}

Ipv6Persistence::~Ipv6Persistence()
{
}

void Ipv6Persistence::load()
{
  Ipv6Setting * setting = static_cast<Ipv6Setting *>(m_setting);
  {
    QString contents = m_config->readEntry("method", "Ignore");
    if (contents == "Automatic")
      setting->setMethod(Ipv6Setting::EnumMethod::Automatic);
    else     if (contents == "LinkLocal")
      setting->setMethod(Ipv6Setting::EnumMethod::LinkLocal);
    else     if (contents == "Manual")
      setting->setMethod(Ipv6Setting::EnumMethod::Manual);
    else     if (contents == "Shared")
      setting->setMethod(Ipv6Setting::EnumMethod::Shared);
    else     if (contents == "Ignore")
      setting->setMethod(Ipv6Setting::EnumMethod::Ignore);
  }

  // dns
  QList<QHostAddress> dnsServers;
  QStringList rawDnsServers = m_config->readEntry("dns", QStringList());
  foreach (const QString &server, rawDnsServers) {
      dnsServers.append(QHostAddress(server));
  }
  setting->setDns(dnsServers);

  setting->setDnssearch(m_config->readEntry("dnssearch", QStringList()));

  // addresses
  QList<Solid::Control::IPv6Address> addresses;
  QStringList rawAddresses = m_config->readEntry("addresses", QStringList());
  foreach (const QString &rawAddress, rawAddresses) {
      QStringList parts = rawAddress.split(';');
      if (parts.count() != 3) { // sanity check
          continue;
      }
      QHostAddress ip(parts[0]);
      QHostAddress gateway(parts[2]);
      Solid::Control::IPv6Address addr(ip.toIPv6Address(), parts[1].toUInt(), gateway.toIPv6Address());
      addresses.append(addr);
  }
  setting->setAddresses(addresses);

  // routes
  QList<Solid::Control::IPv6Route> routes;
  QStringList rawRoutes = m_config->readEntry("routes", QStringList());
  foreach (const QString &rawRoute, rawRoutes) {
      QStringList parts = rawRoute.split(';');
      if (parts.count() != 4) { // sanity check
          continue;
      }
      QHostAddress address(parts[0]);
      quint32 prefix = parts[1].toUInt();
      QHostAddress nextHop(parts[2]);
      quint32 metric = parts[3].toUInt();
      Solid::Control::IPv6Route route(address.toIPv6Address(), prefix, nextHop.toIPv6Address(), metric);
      routes.append(route);
  }
  setting->setRoutes(routes);
  setting->setIgnoredhcpdns(m_config->readEntry("ignoredhcpdns", false));
  setting->setIgnoreautoroute(m_config->readEntry("ignoreautoroute", false));
  setting->setNeverdefault(m_config->readEntry("neverdefault", false));
  setting->setMayfail(m_config->readEntry("mayfail", true));
  setting->setInitialized();
}

void Ipv6Persistence::save()
{
  Ipv6Setting * setting = static_cast<Ipv6Setting *>(m_setting);
  switch (setting->method()) {
    case Ipv6Setting::EnumMethod::Automatic:
      m_config->writeEntry("method", "Automatic");
      break;
    case Ipv6Setting::EnumMethod::LinkLocal:
      m_config->writeEntry("method", "LinkLocal");
      break;
    case Ipv6Setting::EnumMethod::Manual:
      m_config->writeEntry("method", "Manual");
      break;
    case Ipv6Setting::EnumMethod::Shared:
      m_config->writeEntry("method", "Shared");
      break;
    case Ipv6Setting::EnumMethod::Ignore:
      m_config->writeEntry("method", "Ignore");
      break;
  }

  QStringList rawDns;
  foreach (const QHostAddress &dns, setting->dns()) {
    rawDns.append(dns.toString());
  }

  m_config->writeEntry("dns", rawDns);

  m_config->writeEntry("dnssearch", setting->dnssearch());

  QStringList rawAddresses;
  foreach (const Solid::Control::IPv6Address &addr, setting->addresses()) {
      QStringList rawAddress;
      rawAddress << QHostAddress(addr.address()).toString()
          << QString::number(addr.netMask())
          << QHostAddress(addr.gateway()).toString();
      rawAddresses << rawAddress.join(";");
  }
  m_config->writeEntry("addresses", rawAddresses);

  QStringList rawRoutes;
  foreach (const Solid::Control::IPv6Route &route, setting->routes()) {
      QStringList rawRoute;
      rawRoute << QHostAddress(route.route()).toString()
          << QString::number(route.prefix())
          << QHostAddress(route.nextHop()).toString()
          << QString::number(route.metric());
      rawRoutes << rawRoute;
  }
  m_config->writeEntry("routes", rawRoutes.join(";"));

  m_config->writeEntry("ignoredhcpdns", setting->ignoredhcpdns());
  m_config->writeEntry("ignoreautoroute", setting->ignoreautoroute());
  m_config->writeEntry("neverdefault", setting->neverdefault());
  m_config->writeEntry("mayfail", setting->mayfail());
}

QMap<QString,QString> Ipv6Persistence::secrets() const
{
  QMap<QString,QString> map;
  return map;
}

void Ipv6Persistence::restoreSecrets(QMap<QString,QString> secrets) const
{
  Q_UNUSED(secrets);
  if (m_storageMode == ConnectionPersistence::Secure) {
  }
}
